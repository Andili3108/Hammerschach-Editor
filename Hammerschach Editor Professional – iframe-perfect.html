<!-- Hammerschach Editor Premium V1-Clean | Functionally identical | Structure optimized | Generated 2025-10-28 04:33:51 -->
<!-- Hammerschach Editor — Professional | V5-Final-Clean | 2025-10-25 12:02:37 | Cleaned: whitespace + formatting only (no logic changes) -->
<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>Hammerschach Editor — Professional</title>
<link href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAG00lEQVRYR8WXC3BU5RXHf/e1ryRsSIKkRQIZWgkvAaMVOhUnEG1oAZ1Whg6lgMViKk0xtkNwCrQdLB2VWsyg0pciFUiCQyzYFhm00kLRomOEJCBgSAwGCAnZvLN7Xz13o0JHhiaZYr+du3f3m2/v+Z9z/ud/ziquLP6PSxkoAMdx6OjoiENPSkpCUZQBuTEgAC0tF3nmmWKeevo3+IyQ3DcwM2/WgEAMCMCGDU/w+Ppf49o6irySwn6OHav+7AA8+9zveGTtWqJR0DWVm26eTPnO8s8uBVGxvGrVSrZuLcPnM9i06Wny8r527QHU1dVytLKC4uJiqqpO4DqqGHUJBDUWL/ou06fnMGLECIYPz+gzmH5xYPPm51j1kzU4kvfLlyOFrAgQVbHYvn0b06blXBsAkUiE7OypdHd3icVL8uG4CqrAuu22qZSUlPaLjP2KgOdWUdGP+eMLJfLJC3/vcl1VjFpseX4zubm5ffbeO9hvADU175MzIxcz5nxiSBHvU9MG8fZbFRiGcW0BeE/PmzmTd49UXmKCqPkPly9jZdHD/TI+oAh4rePUqVNYloUnx6qqouu6RCCVlMEp1xaAZ/zll3dRvPEpak7UYyndaK4hchxk8s1f5PavfJnvLFxKKCGxz0TsNwe8PrDi4RXs2v26GDdxFRtbUZkyZhRfykwjWHUcLZRA3ronybrl1v8akasCqBF9b/7Xm1wwTUJSdaZt0akrtL9bwfpdr3DO8urfZMLYTMZGu/l6Ww8ZdpRmv0bzqNGk5OSSkTMdO2qi+wJcPzrrU5G5KoCK/a9RX1SA1dVDmh5AtV3qnE7Sg2F+q2js+zCCz7WZf8ctTD1aSZbwwpZ91dGIGSbSKqg1IUF+26D5mfLYo0wSUJevqwJoPtvAX2ffwY22iSaE8/y1VIUGPcT+rC+w5dXDcTmYNVgn3wgQEACWKooowmQ4NlHdQbMN/qmZpNxfQN6C+0hITOo7AI90f9/+ArXS7ye3d2CrDlVKEGXWDA5evMBL5a+iS0tekhpgriaCJEOJLZdhI2ehSzc4GdBJuHMmuQ+uJDEc/hQn4hG4cKGRdyqOkBx2CUljOdcoORO5H5RscebDTt7eVsrs905ICmw2+UNMXDKP8rJdHD9Wi41BfrLKXB9SFTIdSPg1xyKqGPwt1o2xYB7hYePwJRrcND6N5ohLpM1i3JjxZGRk9Crh3r17WXTvvax4MEjejCHcs/AEYzKCPF4cZs3POzj5msOTQ9PEoyhFta1MnD2Effsa6LQCYt7kzoQQDwVCuGpMwv9RqxLSxiRd/wjH+EMNdPtb2bljNFtKGtm+LSKi9QjLfvBAL4A3Du3hXP2P+MueCIcORygqzOBUjSkhbuKreWGyh2qklwXEW403b+3kwHsW71SLx6ol3mrcIJFZN/xzhM12+S77mospEQxYLlFNQCQKVeamsHFDNTdmBylcdh3nW7/HXXcv7wVw8MAr7Nu7lKZGh6Zml4zhGpF2N55Hv6sxtMvh7qoAXcKBkiEOe+qitLaLBTEu2SZR+vHq9DCTJBqGB0CI6PVKr2l711nd5flUk9SRNq0dhqgmTM5+iAULCy6l4L7F+Sx5AHKnp1Fwfx2Dhyo8sS6dX/7qIrwFK2XyNdwuNvUE2NkWE3AxIR1COHmTbvjtBIv5ckYVEGLfY2TcuPexRfezqqOOdb+/gdKdzby4I8bq1WvIz8/vBRCLxWhtbRNtj8plIl+xLe/exsHdfyZYsk1K0aJZOt1Pz7dTLZOQJh3QM2RK3Se7UR5LT2eU3SN7ok7xLtM7tHgAKoUfn1/7C7ImTUbTvG6pEQqFCAaloq72v6C9pZndS+cz4eTp+ABS1uPybGtU2B63gC5l6hc5npNgsMTTf0mHKnuOnO313wuEy/thHxM3ljFywvgrl+GVBPvk8eO8WLyezPMfYDR1cLo1QmljBw2uN4rbwnBVvHO4Xt5nhxNJtDsEoxb3+DqZDXw+XTqlDGpeNegaSXO+xTcKCvsOoKm2lvMHDtFSf5razjY2vvQnPmjpFKERlXF9+GwxpkQZGTK4PZyMX5Tv4+UzNHTjo7lRAHuza9aixcxZ+v2+A4iHT+BXv/E6O0q2EpH5X3GMeD+I0hlPgVdqSlsE63A1Saoo0SezqkU4JYUhw4bJQzxdsBk/bwHT7rqnfwC80/Vn6qk8eoSYeOia0npNix7pbj09MRrOnuFweSkpogNS7nFQHu08HngcGJQcJCXNI5pK5pRcvrm8CMPv/w8Q/Z4HLv91tL2N/Y/+DPViG5YAc8XbjyPXe653ctYEUKcmQ0thIZljx/3vAFyJvP3d+zf6oTnOmiu28QAAAABJRU5ErkJggg==" rel="icon" type="image/png"/>
<style>
  :root { --board-size:600px; --accent:#0b63d4; --bg:#f6f7fb; }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial;background:#f6f7fb;color:#111}
  max-width: 1100px;
  width: 100%; height:150px; margin:28px auto; padding:26px 10px 22px;
    color:#fff; background: linear-gradient(90deg,#3b6ea7 0%,#843f46 20%,#843f46 80%,#3b6ea7 100%);
    border-radius:16px; box-shadow:0 8px 18px rgba(0,0,0,.15); text-align:center;
    display:flex; flex-direction:column; align-items:center; justify-content:center; box-sizing:border-box;
  }

  .page {
  max-width: 1100px;
  margin: 0 auto 40px;
  padding: 12px;
  box-sizing: border-box;
  display: flex;
  gap: 18px;
  align-items: flex-start;
  justify-content: center;
}
  .board-col{width:var(--board-size);display:flex;flex-direction:column;align-items:center;gap:8px;position:relative}
  .sidebar {
  width: 420px;
  min-width: 320px;
  display: flex;
  flex-direction: column;
  gap: 10px;
}
  .mgmt{width:100%;display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:4px}
  .mgmt button{background:#e9ecf0;color:#222;border:1px solid #d1d6dd;padding:6px 10px;border-radius:6px;font-weight:600;cursor:pointer}
  .mgmt button.primary{background:var(--accent);color:#fff;border:none}
  .mgmt button:hover{filter:brightness(0.98)}
  #board{width:var(--board-size);height:var(--board-size);border:3px solid #333;box-shadow:0 6px 14px rgba(0,0,0,.08);
         display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);user-select:none;position:relative;background:#eee}
  .square{display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative}
  .light{background:#f0d9b5cc}.dark{background:#843f46cc}
  .piece{font-size:56px;line-height:1}
  .controls{display:flex;gap:8px;margin-top:6px;flex-wrap:wrap;justify-content:center}
  button.ctrl{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:6px;font-weight:600;cursor:pointer}
  button.ctrl.ghost{background:transparent;color:var(--accent);border:1px solid rgba(11,99,212,.15)}
  .box{background:#fff;padding:10px;border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.05)}
  .pgn-row{display:grid;grid-template-columns:1fr 1fr;gap:8px}
  label{font-size:13px;color:#333}
  input[type="text"]{width:100%;padding:8px;border-radius:6px;border:1px solid #ddd;box-sizing:border-box}
  input[readonly]{background:#f3f4f7;color:#444}
  .moves{background:#fff;padding:8px;border-radius:8px;box-shadow:0 6px 14px rgba(0,0,0,0.05);max-height:640px;overflow:auto;font-size:14px}
  .moves-pre{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,"Roboto Mono",monospace;white-space:pre-wrap;line-height:1.6;font-size:13px}
  .status{text-align:center;font-weight:600;padding-top:4px;min-height:28px;color: #843f46;margin-top: 20px;}
  .modal-backdrop{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;z-index:1000}
  .modal{background:#fff;border-radius:12px;box-shadow:0 16px 40px rgba(0,0,0,.3);width:480px;max-width:96vw;padding:14px}
  .modal h3{margin:0 0 10px 0}
  .game-list{max-height:50vh;overflow:auto;border:1px solid #e5e7eb;border-radius:8px}
  .game-item{padding:10px 12px;border-bottom:1px solid #eef1f4;cursor:pointer;display:flex;justify-content:space-between;align-items:center}
  .game-item:last-child{border-bottom:none}
  .game-item:hover{background:#f7f9fb}
  .game-item.active{background:#e9f0ff;border-left:3px solid var(--accent)}
  .modal .actions{display:flex;justify-content:flex-end;gap:8px;margin-top:12px}
  .tag{font-size:12px;color:#666}
  footer{text-align:center;font-size:.9rem;color:#666;margin:12px 0 0}

  /* Klickbare Zugliste */
  .mv { cursor: pointer; padding: 2px 4px; border-radius: 4px; display: inline-block; }
  .mv:hover { background: rgba(11,99,212,.08); }
  .mv.active { background: rgba(11,99,212,.18); }

/* === r2d additions (append-only) === */
:root{--board-size:600px;}
.sidebar{display:flex;flex-direction:column;height:var(--board-size)}
.sidebar .moves{flex:1 1 auto;min-height:0;overflow-y:auto;scrollbar-gutter:stable}
#movesPre {
  display: flex;
  flex-wrap: wrap;
  gap: 4px 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
  line-height: 1.5;
  font-size: 15px;
  padding: 10px 12px;
  border: 1px solid #bbb;
  border-radius: 8px;
  background: #fff;
  box-sizing: border-box;
  width: 100%;
  overflow-y: auto;
}

#movesPre .mv {
  min-width: 60px;
  text-align: left;
  cursor: pointer;
  user-select: none;
}

#movesPre .mv:hover {
  background: rgba(11,99,212,0.08);
  border-radius: 4px;
}
.mgmt{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
.mgmt button{width:100%;height:42px}
/* === end r2d css === */
/* === Breitenkorrektur der Zuglistenbox (stabil) === */
.sidebar .moves {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
  scrollbar-gutter: stable;
  padding: 0;
}

#movesPre {
  display: flex;
  flex-wrap: wrap;
  gap: 4px 12px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
  line-height: 1.5;
  font-size: 15px;
  padding: 10px 12px;
  border: 1px solid #bbb;
  border-radius: 8px;
  background: #fff;
  box-sizing: border-box;
  width: 100%;
  overflow-y: auto;
}

#movesPre .mv {
  min-width: 60px;
  text-align: left;
  cursor: pointer;
  user-select: none;
}

#movesPre .mv:hover {
  background: rgba(11,99,212,0.08);
  border-radius: 4px;
}

.mv-num {
  color: #555;
  font-weight: 600;
  margin-right: 4px;
}

.mv {
  display: inline-block;
  padding: 0 3px;
  border-radius: 4px;
  cursor: pointer;
  transition: background 0.15s;
}

.mv:hover {
  background: rgba(11,99,212,0.08);
}

.mv.active {
  background: #dbe9ff;
  font-weight: 700;
}

/* === Sidebar rechts neben dem Brett (NoHeader-Fix mit Feinschliff) === */
.page {
  display: flex;
  flex-wrap: nowrap;
  align-items: flex-start;
  justify-content: center;
  gap: 22px;
  max-width: 1100px;
  margin: 8px auto 0; /* sanfter Abstand nach oben statt Header */
  padding: 0 16px;
  box-sizing: border-box;
}

.board-col {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  position: relative;
}

.sidebar {
  display: flex;
  flex-direction: column;
  width: 420px;
  min-width: 320px;
  height: auto;
  margin-top: 0 !important;
  box-sizing: border-box;
}

.sidebar .moves {
  flex: 1 1 auto;
  min-height: 0;
  overflow-y: auto;
}

/* Seite optisch leicht ausbalancieren */
body {
  background: #f6f7fb;
  font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  margin: 0;
  color: #111;
}

/* === Promotion Modal Styles === */
.promo-grid{
  display:grid;
  grid-template-columns:repeat(2,1fr);
  gap:10px;
  margin-top:8px;
}
.promo-btn{
  display:flex;
  align-items:center;
  justify-content:flex-start;
  gap:10px;
  padding:10px 12px;
  border-radius:10px;
  border:1px solid #d1d6dd;
  background:#f9fafb;
  cursor:pointer;
  font-weight:600;
}
.promo-btn:hover{ filter:brightness(0.98); background:#fff; }
.promo-btn .pi{ font-size:28px; line-height:1; width:32px; text-align:center; }

</style>
<style id="marking-final-css">
/* === V3-r2 FINAL: Innenrahmen-Markierung (3px, #3b6ea7) === */
.square.source::after,
.square.target::after {
  content: "";
  position: absolute;
  top: 3px; left: 3px; right: 3px; bottom: 3px;
  border: 3px solid #3b6ea7;
  border-radius: 2px;
  pointer-events: none;
  box-sizing: border-box;
}

</style>
<style id="pgn-import-css">
/* PGN-Import Popup (600x400, zentriert) */
#pgnImportBackdrop { position: fixed; inset: 0; background: rgba(0,0,0,.45); display: none; align-items: center; justify-content: center; z-index: 1200; }
#pgnImportModal { width: 600px; height: 400px; max-width: 96vw; max-height: 96vh; background: #fff; border-radius: 12px; box-shadow: 0 16px 40px rgba(0,0,0,.3); display:flex; flex-direction:column; }
.pgn-import-title{height:42px;display:flex;align-items:center;justify-content:center;background:#843f46;color:#fff;font-weight:800;border-top-left-radius:12px;border-top-right-radius:12px;}
#pgnImportModal .content { padding: 12px 14px; flex: 1 1 auto; display:flex; flex-direction:column; gap: 8px; }
#pgnImportModal .actions { padding: 12px 14px; border-top: 1px solid #e5e7eb; display:flex; justify-content:flex-end; gap: 8px; }

#pgnImportText { width: 100%; height: 100%; min-height: 0; resize: none; border: 1px solid #d1d6dd; border-radius: 8px; padding: 10px;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; line-height: 1.5; font-size: 14px; box-sizing: border-box; background:#fff; }

/* Scrollbar an Zugliste angelehnt */
#pgnImportText { scrollbar-gutter: stable; }
#pgnImportText::-webkit-scrollbar { width: 10px; }
#pgnImportText::-webkit-scrollbar-thumb { background: #bbb; border-radius: 6px; }
#pgnImportText::-webkit-scrollbar-thumb:hover { background: #999; }

/* Buttons */
button.primary { background: var(--accent); color: #fff; border: none; }
button.ghost { background: transparent; color: var(--accent); border: 1px solid rgba(11,99,212,.15); }
</style>
<style id="moves-classic-css">
/* === V5-r20: Klassische Zugliste (Nummer | Weiß | Schwarz) === */
.sidebar .moves { padding: 0; background: transparent; box-shadow: none; }

#movesPre {
  display: block !important;            /* Container als Block, wir bauen eigene Zeilen */
  padding: 0;
  border: none;
  background: transparent;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
  font-size: 15px;
  line-height: 1.5;
}

.mv-table {
  display: grid;
  grid-template-columns: 64px 1fr 1fr;  /* Nummer fix, Züge flexibel */
  column-gap: 10px;
  row-gap: 2px;
  padding: 10px 12px;
  border: 1px solid #cfd6df;
  border-radius: 10px;
  background: #fff;
  box-shadow: 0 6px 14px rgba(0,0,0,.05);
}

.mv-row {
  display: contents; /* jede Zeile ist logisch, Layout über Grid der Tabelle */
}

.mv-num {
  color: #3b6ea7;
  font-weight: 800;
  text-align: right;
  padding-right: 6px;
}

.mv-cell {
  display: inline-flex;
  align-items: center;
  min-height: 28px;
  padding: 0 6px;
  border-radius: 6px;
  position: relative;
  user-select: none;
}

.mv-cell .mv {
  display: inline-block;
  padding: 2px 0;
  border-radius: 6px;
  cursor: pointer;
}

.mv:hover { background: rgba(11,99,212,.08); }
.mv.active {
  background: #dbe9ff;
  font-weight: 700;
  outline: 1px solid rgba(11,99,212,.35);
}

/* Sehr lange SAN-Züge dürfen umbrechen, aber nicht die Nummernsäule verschieben */
.mv { white-space: normal; word-break: break-word; }

/* Scrollbar optisch beruhigt */
#movesPre::-webkit-scrollbar { width: 10px; }
#movesPre::-webkit-scrollbar-thumb { background: #bbb; border-radius: 6px; }
#movesPre::-webkit-scrollbar-thumb:hover { background: #999; }

/* Responsive Feinschliff */
@media (max-width: 980px) {
  .mv-table { grid-template-columns: 56px 1fr 1fr; }
  .mv-num { padding-right: 4px; }
}
</style>
<style id="scroll-fix-50-css">
/* Extra Sichtbarkeits-Puffer für .mv.active */
#movesPre .mv.active { scroll-margin: 36px 0; }
</style>

<style id="iframe-perfect-css">
/* === iframe-perfect overrides === */
html, body { height: 100%; overflow: hidden; }  /* never show a page scroll bar inside iframe */
.page { margin: 4px auto 0 !important; }
footer { margin: 6px 0 0 !important; }
.sidebar { height: var(--board-size) !important; min-height: 0 !important; }
.moves { max-height: none !important; } /* internal move list can scroll inside its own box if needed */
#movesPre { max-height: none !important; }
</style>

</head>
<body>

<input accept=".pgn,text/plain" id="fileInputPGN" style="display:none" type="file"/>
<div class="page">
<div class="board-col">
<div class="mgmt">
<button id="btnOpenPGN">📂 PGN öffnen</button>
<button id="btnImportPGNText">📝 PGN einfügen</button>
<button id="btnShowList">🗂️ Partieliste</button>
<button id="btnAddGame">➕ Partie hinzufügen</button>
<button class="primary" id="btnExportAll">💾 PGN erstellen</button>
</div>
<div aria-label="Schachbrett" id="board"></div>
<div class="controls">
<button class="ctrl" id="btnStart" title="Zum Anfang der Partie">«</button>
<button class="ctrl" id="btnBack" title="Einen Zug zurück">‹</button>
<button class="ctrl" id="btnForward" title="Einen Zug vorwärts">›</button>
<button class="ctrl" id="btnEnd" title="Zum Ende der Partie">»</button>
<button class="ctrl ghost" id="btnUndo" title="Rückgängig">Rückgängig</button>
<button class="ctrl ghost" id="btnFlip" title="Brett drehen">Flip</button>
<button class="ctrl" id="btnSave">Speichern</button>
</div>
<div class="box status" id="status">Weiß am Zug — Partie <span id="gameIndexLabel">1</span> von <span id="gameCountLabel">1</span></div>
</div>
<aside class="sidebar">
<div class="box">
<div class="pgn-row">
<div><label>Event</label><input id="hdrEvent" type="text" value="?"/></div>
<div><label>Site</label><input id="hdrSite" type="text" value="?"/></div>
</div>
<div class="pgn-row" style="margin-top:8px;">
<div><label>Date</label><input id="hdrDate" type="text" value="?"/></div>
<div><label>Round</label><input id="hdrRound" type="text" value="?"/></div>
</div>
<div class="pgn-row" style="margin-top:8px;">
<div><label>White</label><input id="hdrWhite" type="text" value="?"/></div>
<div><label>Black</label><input id="hdrBlack" type="text" value="?"/></div>
</div>
<div class="pgn-row" style="margin-top:8px;">
<div><label>Result</label><input id="hdrResult" type="text" value="*"/></div>
<div><label>ECO</label><input id="hdrECO" readonly="" type="text" value="?"/></div>
</div>
<div class="pgn-row" style="margin-top:8px;">
<div><label>WhiteElo</label><input id="hdrWhiteElo" type="text" value="?"/></div>
<div><label>BlackElo</label><input id="hdrBlackElo" type="text" value="?"/></div>
</div>
<div class="pgn-row" style="margin-top:8px;">
<div><label>PlyCount</label><input id="hdrPlyCount" readonly="" type="text" value="0"/></div>
<div></div>
</div>
</div>
<div class="moves box" id="moveBox">
<div class="moves-pre" id="movesPre">Noch keine Züge.</div>
</div>
</aside>
</div>
<div aria-hidden="true" class="modal-backdrop" id="modalBackdrop">
<div aria-labelledby="gameListTitle" aria-modal="true" class="modal" role="dialog">
<h3 id="gameListTitle">🗂️ Gespeicherte Partien</h3>
<div class="game-list" id="gameList"></div>
<div class="actions">
<button id="btnCloseList">Schließen</button>
</div>
</div>
</div>
<footer>© 2025 — Andreas Lipske</footer>
<script type="module">
document.addEventListener('DOMContentLoaded',()=>{

const files=['a','b','c','d','e','f','g','h'];
function coordToAlg(x,y){ return files[x]+(8-y); }
function clone(o){ return JSON.parse(JSON.stringify(o)); }
function pieceColor(ch){ if(!ch||ch==='.') return null; return ch===ch.toUpperCase()?'w':'b'; }
function charFor(p){ switch(p){ case 'P': return '♙'; case 'R': return '♖'; case 'N': return '♘'; case 'B': return '♗'; case 'Q': return '♕'; case 'K': return '♔';
                                case 'p': return '♟'; case 'r': return '♜'; case 'n': return '♞'; case 'b': return '♝'; case 'q': return '♛'; case 'k': return '♚'; default: return ''; }}

function Game(){ this.reset(); }
Game.prototype.reset=function(){
  this.board=[['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['.','.','.','.','.','.','.','.'],['.','.','.','.','.','.','.','.'],['.','.','.','.','.','.','.','.'],['.','.','.','.','.','.','.','.'],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
  this.turn='w'; this.ep=null; this.castling={K:true,Q:true,k:true,q:true}; this.halfmove=0; this.fullmove=1; this.history=[];
};
Game.prototype.clone=function(){ const g=new Game(); g.board=clone(this.board); g.turn=this.turn; g.ep=this.ep? [this.ep[0],this.ep[1]]:null; g.castling=Object.assign({},this.castling); g.halfmove=this.halfmove; g.fullmove=this.fullmove; g.history=clone(this.history); return g; };
Game.prototype.at=function(x,y){ return this.board[y][x]; };
Game.prototype.set=function(x,y,v){ this.board[y][x]=v; };
Game.prototype.inBounds=function(x,y){ return x>=0&&x<8&&y>=0&&y<8; };
Game.prototype.findKing=function(color){ const k=color==='w'?'K':'k'; for(let y=0;y<8;y++) for(let x=0;x<8;x++) if(this.board[y][x]===k) return [x,y]; return null; };

Game.prototype.isAttacked=function(tx,ty,byColor){
  const dir = byColor==='w' ? -1 : 1;
  const pawn = byColor==='w' ? 'P' : 'p';
  for(const dx of [-1,1]){ const x = tx+dx, y = ty+dir; if(this.inBounds(x,y) && this.board[y][x]===pawn) return true; }
  const knight=byColor==='w'?'N':'n'; const kM=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
  for(const m of kM){ const x=tx+m[0], y=ty+m[1]; if(this.inBounds(x,y) && this.board[y][x]===knight) return true; }
  const bishop=byColor==='w'?'B':'b', queen=byColor==='w'?'Q':'q', rook=byColor==='w'?'R':'r', king=byColor==='w'?'K':'k';
  const diags=[[1,1],[1,-1],[-1,1],[-1,-1]];
  for(const d of diags){ let x=tx+d[0], y=ty+d[1]; while(this.inBounds(x,y)){ const p=this.board[y][x]; if(p!=='.'){ if(p===bishop||p===queen) return true; break; } x+=d[0]; y+=d[1]; } }
  const orth=[[1,0],[-1,0],[0,1],[0,-1]];
  for(const d of orth){ let x=tx+d[0], y=ty+d[1]; while(this.inBounds(x,y)){ const p=this.board[y][x]; if(p!=='.'){ if(p===rook||p===queen) return true; break; } x+=d[0]; y+=d[1]; } }
  for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){ if(dx===0&&dy===0) continue; const x=tx+dx,y=ty+dy; if(this.inBounds(x,y) && this.board[y][x]===king) return true; }
  return false;
};

Game.prototype.pseudoLegalMovesFrom=function(x,y){
  const moves=[]; const p=this.at(x,y); if(!p||p==='.') return moves;
  const color=(p===p.toUpperCase())?'w':'b'; const dir=(color==='w')?-1:1; const piece=p.toLowerCase();
  if(piece==='p'){
    const ny=y+dir;
    if(this.inBounds(x,ny) && this.at(x,ny)==='.') { moves.push([x,ny,null]); const start=(color==='w')?6:1; const ny2=y+2*dir; if(y===start && this.at(x,ny2)==='.') moves.push([x,ny2,{ep:[x,ny]}]); }
    for(const dx of [-1,1]){
      const nx=x+dx, nyc=y+dir;
      if(this.inBounds(nx,nyc)){
        const t=this.at(nx,nyc);
        if(t!=='.' && pieceColor(t)!==color) moves.push([nx,nyc,null]);
      }
      const ep=this.ep;
      if(ep && ep[0]===x+dx && ep[1]===y+dir) moves.push([x+dx,y+dir,{enpassant:true}]);
    }
  } else if(piece==='n'){
    const steps=[[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
    for(const s of steps){
      const nx=x+s[0], ny=y+s[1];
      if(!this.inBounds(nx,ny)) continue;
      const t=this.at(nx,ny);
      if(t=='.' || pieceColor(t)!==color) moves.push([nx,ny,null]);
    }
  } else if(['b','r','q'].includes(piece)){
    const dirs = piece==='b' ? [[1,1],[1,-1],[-1,1],[-1,-1]] : piece==='r' ? [[1,0],[-1,0],[0,1],[0,-1]] : [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
    for(const d of dirs){
      let nx=x+d[0], ny=y+d[1];
      while(this.inBounds(nx,ny)){
        const t=this.at(nx,ny);
        if(t=='.') moves.push([nx,ny,null]);
        else { if(pieceColor(t)!==color) moves.push([nx,ny,null]); break; }
        nx+=d[0]; ny+=d[1];
      }
    }
  } else if(piece==='k'){
    for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
      if(dx===0&&dy===0) continue;
      const nx=x+dx, ny=y+dy;
      if(!this.inBounds(nx,ny)) continue;
      const t=this.at(nx,ny);
      if(t=='.' || pieceColor(t)!==color) moves.push([nx,ny,null]);
    }
    if(color==='w'){
      if(this.castling.K){ if(this.at(5,7)==='.' && this.at(6,7)==='.') moves.push([6,7,{castle:'K'}]); }
      if(this.castling.Q){ if(this.at(1,7)==='.' && this.at(2,7)==='.' && this.at(3,7)==='.') moves.push([2,7,{castle:'Q'}]); }
    } else {
      if(this.castling.k){ if(this.at(5,0)==='.' && this.at(6,0)==='.') moves.push([6,0,{castle:'k'}]); }
      if(this.castling.q){ if(this.at(1,0)==='.' && this.at(2,0)==='.' && this.at(3,0)==='.') moves.push([2,0,{castle:'q'}]); }
    }
  }
  return moves;
};

Game.prototype.legalMoves=function(){
  const moves=[]; const side=this.turn;
  for(let y=0;y<8;y++) for(let x=0;x<8;x++){
    const p=this.at(x,y); if(p=='.') continue; const color=(p===p.toUpperCase())?'w':'b'; if(color!==side) continue;
    const pseud=this.pseudoLegalMovesFrom(x,y);
    for(const pm of pseud){
      const nx=pm[0], ny=pm[1], meta=pm[2];
      const sim=this.clone();
      const piece=sim.at(x,y);
      if(meta && meta.enpassant){
        sim.set(nx,y,'.'); sim.set(nx,ny,piece); sim.set(x,y,'.');
      } else if(meta && meta.castle){
        if(meta.castle==='K'){ sim.set(4,7,'.'); sim.set(6,7,'K'); sim.set(7,7,'.'); sim.set(5,7,'R'); }
        else if(meta.castle==='Q'){ sim.set(4,7,'.'); sim.set(2,7,'K'); sim.set(0,7,'.'); sim.set(3,7,'R'); }
        else if(meta.castle==='k'){ sim.set(4,0,'.'); sim.set(6,0,'k'); sim.set(7,0,'.'); sim.set(5,0,'r'); }
        else if(meta.castle==='q'){ sim.set(4,0,'.'); sim.set(2,0,'k'); sim.set(0,0,'.'); sim.set(3,0,'r'); }
      } else { sim.set(nx,ny,piece); sim.set(x,y,'.'); }
      const kp=sim.findKing(side);
      if(kp && !sim.isAttacked(kp[0],kp[1], side==='w'?'b':'w')) moves.push({from:[x,y],to:[nx,ny],meta:meta});
    }
  }
  return moves;
};

Game.prototype.makeMove=function(mv){
  const fx=mv.from[0], fy=mv.from[1], tx=mv.to[0], ty=mv.to[1];
  const piece=this.at(fx,fy);
  const meta=mv.meta||{};
  let taken='.';
  if(meta.enpassant){ taken=this.at(tx,fy); this.set(tx,fy,'.'); }
  if(meta.castle){
    if(meta.castle==='K'){ this.set(4,7,'.'); this.set(6,7,'K'); this.set(7,7,'.'); this.set(5,7,'R'); }
    else if(meta.castle==='Q'){ this.set(4,7,'.'); this.set(2,7,'K'); this.set(0,7,'.'); this.set(3,7,'R'); }
    else if(meta.castle==='k'){ this.set(4,0,'.'); this.set(6,0,'k'); this.set(7,0,'.'); this.set(5,0,'r'); }
    else if(meta.castle==='q'){ this.set(4,0,'.'); this.set(2,0,'k'); this.set(0,0,'.'); this.set(3,0,'r'); }
  } else {
    taken=this.at(tx,ty);
    this.set(tx,ty,this.at(fx,fy));
    this.set(fx,fy,'.');
  }
  // -- Promotion handling: if pawn reaches last rank and mv.meta.promote is set, replace piece --
  if((piece==='P'||piece==='p') && (ty===0 || ty===7) && mv && mv.meta && mv.meta.promote){
    const up = String(mv.meta.promote||'q').toUpperCase();
    const map = {Q:'Q',R:'R',B:'B',N:'N'};
    const finalPiece = (piece==='P') ? (map[up]||'Q') : (map[up]||'Q').toLowerCase();
    this.set(tx, ty, finalPiece);
  }

  this.ep=null;
  if((piece==='P'||piece==='p') && Math.abs(ty-fy)===2){ this.ep=[fx,(fy+ty)/2]; }
  if(piece==='K'){ this.castling.K=false; this.castling.Q=false; }
  if(piece==='k'){ this.castling.k=false; this.castling.q=false; }
  if(piece==='R'&&fx===0&&fy===7) this.castling.Q=false;
  if(piece==='R'&&fx===7&&fy===7) this.castling.K=false;
  if(piece==='r'&&fx===0&&fy===0) this.castling.q=false;
  if(piece==='r'&&fx===7&&fy===0) this.castling.k=false;
  if((piece.toLowerCase()==='p') || taken!=='.') this.halfmove=0; else this.halfmove++;
  if(this.turn==='b') this.fullmove++;
  this.history.push({from:[fx,fy],to:[tx,ty],piece:piece,taken:taken,meta:meta});
  this.turn=(this.turn==='w')?'b':'w';
};

Game.prototype.inCheck=function(color){ const kp=this.findKing(color); return this.isAttacked(kp[0],kp[1], color==='w'?'b':'w'); };
Game.prototype.gameOver=function(){ const lm=this.legalMoves(); if(lm.length===0){ if(this.inCheck(this.turn)) return {type:'checkmate',winner:this.turn==='w'?'b':'w'}; else return {type:'stalemate'} } return false; };

function moveToLAN(m){ return coordToAlg(m.from[0],m.from[1]) + coordToAlg(m.to[0],m.to[1]); }

let allePartien=[]; let aktuellePartie=0; let orientationWhite=true;
function defaultHeaders(){ return {Event:"?",Site:"?",Date:"????.??.??",Round:"?",White:"?",Black:"?",Result:"*",ECO:"?",WhiteElo:"?",BlackElo:"?",PlyCount:"0"}; }
function readHeadersFromUI(){ return {Event:val('hdrEvent','?'),Site:val('hdrSite','?'),Date:val('hdrDate','????.??.??'),Round:val('hdrRound','?'),White:val('hdrWhite','?'),Black:val('hdrBlack','?'),Result:val('hdrResult','*'),ECO:val('hdrECO','?'),WhiteElo:val('hdrWhiteElo','?'),BlackElo:val('hdrBlackElo','?'),PlyCount:val('hdrPlyCount','0')}; }
function writeHeadersToUI(h){ set('hdrEvent',h.Event); set('hdrSite',h.Site); set('hdrDate',h.Date); set('hdrRound',h.Round); set('hdrWhite',h.White); set('hdrBlack',h.Black); set('hdrResult',h.Result); set('hdrECO',h.ECO); set('hdrWhiteElo',h.WhiteElo); set('hdrBlackElo',h.BlackElo); set('hdrPlyCount',h.PlyCount||'0'); }
function val(id,fallback){ const el=document.getElementById(id); return (el && el.value && el.value.trim().length)? el.value : fallback; }
function set(id,v){ const el=document.getElementById(id); if(el) el.value=v; }
function newEmptyGame(){ const g=new Game(); g.reset(); return {headers:defaultHeaders(),history:[],orientationWhite:true}; }
function persistCurrentGame(){ const cur=allePartien[aktuellePartie]; if(!cur) return; cur.headers=readHeadersFromUI(); cur.headers.PlyCount=String(cur.history.length); cur.orientationWhite=orientationWhite; }
function loadGame(index){ if(index<0||index>=allePartien.length) return; aktuellePartie=index; const cur=allePartien[index]; writeHeadersToUI(cur.headers); orientationWhite=!!cur.orientationWhite; masterHistory=clone(cur.history||[]); viewIndex=masterHistory.length; renderBoardFromView(); updateGameCounters(); }
function updateGameCounters(){
  try{
    var idxEl = document.getElementById('gameIndexLabel');
    var cntEl = document.getElementById('gameCountLabel');
    if (idxEl) idxEl.textContent = (typeof aktuellePartie !== 'undefined' ? (aktuellePartie + 1) : 1);
    if (cntEl) cntEl.textContent = (typeof allePartien !== 'undefined' && allePartien ? allePartien.length : 1);
  }catch(e){
    // Silent: niemals Blocking-Alert
    console && console.warn && console.warn('updateGameCounters skipped:', e);
  }
}
function buildPGNForGame(g){
  const h=g.headers||defaultHeaders();
  const order=["Event","Site","Date","Round","White","Black","Result","ECO","WhiteElo","BlackElo","PlyCount"];
  let pgn="";
  for(const k of order) pgn+=`[${k} "${h[k]??'?'}"]\n`;
  pgn+="\n";

  if(!g.history||g.history.length===0){
    pgn+=(h.Result||'*')+"\n";
    return pgn;
  }

  // SAN-Helfer (wie in der Zugliste)
  const files=['a','b','c','d','e','f','g','h'];
  const alg=(x,y)=>files[x]+(8-y);
  const buildSAN=(gameBefore,mv)=>{
    if(!mv) return '';
    if(mv.meta && mv.meta.castle)
      return mv.meta.castle==='K'||mv.meta.castle==='k'?'O-O':'O-O-O';
    const p=gameBefore.at(mv.from[0],mv.from[1]);
    const isPawn=p.toUpperCase()==='P';
    const isCap=gameBefore.at(mv.to[0],mv.to[1])!=='.'||(mv.meta&&mv.meta.enpassant);
    let san='';
    if(isPawn){
      san=isCap?files[mv.from[0]]+'x'+alg(mv.to[0],mv.to[1]):alg(mv.to[0],mv.to[1]);
    }else{
      san=p.toUpperCase()+(isCap?'x':'')+alg(mv.to[0],mv.to[1]);
    }
    if(mv.meta&&mv.meta.promote) san+='='+mv.meta.promote.toUpperCase();
    try{
      const sim=gameBefore.clone(); sim.makeMove(mv);
      const over=sim.gameOver&&sim.gameOver();
      if(over&&over.type==='checkmate') san+='#';
      else if(sim.inCheck&&sim.inCheck(sim.turn)) san+='+';
    }catch(e){}
    return san;
  };

  const gtmp=new Game();
  for(let i=0;i<g.history.length;i+=2){
    const num=Math.floor(i/2)+1;
    const w=g.history[i];
    const b=g.history[i+1];
    let wSan='',bSan='';
    if(w){wSan=buildSAN(gtmp,w);gtmp.makeMove(w);}
    if(b){bSan=buildSAN(gtmp,b);gtmp.makeMove(b);}
    pgn+=`${num}. ${wSan}${bSan?' '+bSan:''} `;
  }
  pgn+=(h.Result||'*')+"\n";
  return pgn;
}

// Export Sammlung
async function exportAllPGN(){ persistCurrentGame(); let all=""; for(let i=0;i<allePartien.length;i++){ all+=buildPGNForGame(allePartien[i]); if(i<allePartien.length-1) all+="\n"; } const suggested="Sammlung.pgn"; if(window.showSaveFilePicker){ try{ const handle=await window.showSaveFilePicker({suggestedName:suggested,types:[{description:'PGN-Dateien',accept:{'text/plain':['.pgn']}}]}); const writable=await handle.createWritable(); await writable.write(all); await writable.close(); return; }catch(e){} } const blob=new Blob([all],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=suggested; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1000); }

// Partieliste
const backdrop=document.getElementById('modalBackdrop'); const gameListEl=document.getElementById('gameList');
function openList(){ persistCurrentGame(); renderList(); backdrop.style.display='flex'; }
function closeList(){ backdrop.style.display='none'; }
function renderList(){
  gameListEl.innerHTML='';
  for(let i=0;i<allePartien.length;i++){
    const g=allePartien[i];

    // Skip empty games (no moves) to avoid 'Partieleichen'
    if(!g || !Array.isArray(g.history) || g.history.length===0){ continue; }
const title=`${i+1}. ${g.headers.White||'?'} – ${g.headers.Black||'?'} (${g.headers.Result||'*'})`;
    const div=document.createElement('div');
    div.className='game-item'+(i===aktuellePartie?' active':'');
    const span=document.createElement('span');
    span.textContent=title;
    const tag=document.createElement('span');
    tag.className='tag';
    tag.textContent=`${g.history.length} Halbzüge`;
    const del=document.createElement('button');
    del.textContent='🗑️'; del.title='Partie löschen';
    del.style.border='none'; del.style.background='transparent'; del.style.cursor='pointer'; del.style.marginLeft='8px';
    del.addEventListener('click',(ev)=>{ ev.stopPropagation(); deleteGameAt(i); const list=document.getElementById('gameList'); if(list && list.style.display==='flex'){ openList(); } });
    div.appendChild(span); div.appendChild(tag); div.appendChild(del);
    div.addEventListener('click',()=>{ closeList(); loadGame(i); });
    gameListEl.appendChild(div);
  }
}
function deleteGameAt(index){
  const curTitle = `${index+1}. ${(allePartien[index]?.headers?.White)||'?'} – ${(allePartien[index]?.headers?.Black)||'?'}`;
  const msg = allePartien.length<=1 ? "Dies ist die letzte Partie. Löschen und leere neue Partie anlegen?" : `Partie ${curTitle} wirklich löschen?`;
  if(!window.confirm(msg)) return;
  allePartien.splice(index,1);

  // Fenster 'Gespeicherte Partien' sofort schließen
  closeList();
if(allePartien.length===0){ allePartien.push(newEmptyGame()); aktuellePartie=0; }
  else { if(allePartien.length-1 < aktuellePartie) aktuellePartie=allePartien.length-1; }
  loadGame(aktuellePartie); renderList();
  const listEl = document.getElementById('gameList');
  if(listEl && listEl.style.display === 'flex'){ closeList(); openList(); }
}

// Ansicht/Board
let masterHistory=[]; let viewIndex=0;
const boardEl=document.getElementById('board'); const statusEl=document.getElementById('status'); const movesPre=document.getElementById('movesPre');

function buildGameFromHistory(n){
  const g=new Game();
  for(let i=0;i<n && i<masterHistory.length;i++){
    const m=masterHistory[i];
    const legal=g.legalMoves();
    let found=null;
    for(const lm of legal) if(lm.from[0]===m.from[0] && lm.from[1]===m.from[1] && lm.to[0]===m.to[0] && lm.to[1]===m.to[1]){ found=lm; break; }
    if(found){ if(m && m.meta){ found.meta = Object.assign({}, found.meta||{}, m.meta); } g.makeMove(found); } else { g.makeMove(m); }
  }
  return g;
}

function renderBoardFromView(){
  const g=buildGameFromHistory(viewIndex);
  boardEl.innerHTML='';
  for(let y=0;y<8;y++){
    for(let x=0;x<8;x++){
      const sx=orientationWhite?x:7-x;
      const sy=orientationWhite?y:7-y;
      const div=document.createElement('div');
      div.className='square '+(((sx+sy)%2===0)?'light':'dark');
      div.dataset.x=sx; div.dataset.y=sy;
      const p=g.at(sx,sy);
      if(p!=='.'){                         // <<< FIX: korrektes Zeichnen der Figuren
        const span=document.createElement('div');
        span.className='piece';
        span.textContent=charFor(p);
        div.appendChild(span);
      }
      div.addEventListener('click',()=>onSquareClick(sx,sy));
      boardEl.appendChild(div);
    }
  }
  updateStatusFromGame(g);
  renderMoveList();
// Aktiver Zug bleibt in der Liste sichtbar
document.querySelector('.mv.active')?.scrollIntoView({block: "nearest"});

  const cur=allePartien[aktuellePartie]; if(cur){ cur.history=clone(masterHistory); cur.headers.PlyCount=String(cur.history.length); }
}

function updateStatusFromGame(g){
  const go=g.gameOver(); const base=`Partie ${aktuellePartie+1} von ${allePartien.length}`;
  if(go){ if(go.type==='checkmate') statusEl.textContent=`Schachmatt — ${(go.winner==='w')?'Weiß':'Schwarz'} gewinnt — ${base}`; else statusEl.textContent=`Patt — Unentschieden — ${base}`; }
  else { statusEl.textContent=`${(g.turn==='w')?'Weiß':'Schwarz'} am Zug — ${base}`; }
}

// ===== NEUE FUNKTION (mit x, +, #) =====
function renderMoveList(){
  if(masterHistory.length===0){
    movesPre.textContent='Noch keine Züge.';
    return;
  }

  const parts=[];
  const gtmp = new Game();
  const files=['a','b','c','d','e','f','g','h'];
  const alg=(x,y)=>files[x]+(8-y);

function buildSAN(gameBefore, mv){
  if(!mv) return '';
  // Castling
  if(mv.meta && mv.meta.castle)
    return (mv.meta.castle==='K' || mv.meta.castle==='k') ? 'O-O' : 'O-O-O';

  const files=['a','b','c','d','e','f','g','h'];
  const alg=(x,y)=>files[x]+(8-y);
  const p = gameBefore.at(mv.from[0], mv.from[1]);
  const isPawn = p.toUpperCase()==='P';
  const isCapture = gameBefore.at(mv.to[0], mv.to[1])!=='.' || (mv.meta && mv.meta.enpassant);

  let san = '';

  if(isPawn){
    // Pawn notation: captures require file of origin
    if(isCapture){
      san = files[mv.from[0]] + 'x' + alg(mv.to[0], mv.to[1]);
    }else{
      san = alg(mv.to[0], mv.to[1]);
    }
  } else {
    // Piece letter
    const pieceLetter = p.toUpperCase(); // K Q R B N
    // Disambiguation: find other same-piece candidates that can also move to the same target
    let disamb = '';
    try{
      const legal = gameBefore.legalMoves();
      const sameTarget = legal.filter(m => m.to[0]===mv.to[0] && m.to[1]===mv.to[1]);
      const samePiece = sameTarget.filter(m => gameBefore.at(m.from[0], m.from[1]).toUpperCase() === pieceLetter);

      if(samePiece.length > 1){
        // If from-files differ -> file letter; else if ranks differ -> rank; else full square.
        const myFile = mv.from[0], myRank = 8 - mv.from[1];
        const filesSet = new Set(samePiece.map(m => m.from[0]));
        const ranksSet = new Set(samePiece.map(m => m.from[1]));

        if(filesSet.size > 1){
          disamb = files[myFile];
        } else if(ranksSet.size > 1){
          disamb = String(myRank);
        } else {
          disamb = files[myFile] + String(myRank);
        }
      }
    }catch(e){
      // Fallback: no disambiguation if something goes wrong
    }

    san = pieceLetter + disamb + (isCapture ? 'x' : '') + alg(mv.to[0], mv.to[1]);
  }

  // Promotion (including after captures)
  if(mv.meta && mv.meta.promote){
    san += '=' + mv.meta.promote.toUpperCase();
  }

  // Check / mate indicators by simulating the move
  try{
    const sim = gameBefore.clone();
    sim.makeMove(mv);
    const over = sim.gameOver && sim.gameOver();
    if(over && over.type==='checkmate') san += '#';
    else if(sim.inCheck && sim.inCheck(sim.turn)) san += '+';
  }catch(e){}

  return san;
}

  for(let i=0;i<masterHistory.length;i+=2){
    const num = (i/2|0)+1;
    const w = masterHistory[i];
    const b = masterHistory[i+1];
    let wSan = '', bSan = '';
    if(w){ wSan = buildSAN(gtmp, w); gtmp.makeMove(w); }
    if(b){ bSan = buildSAN(gtmp, b); gtmp.makeMove(b); }
    const wIdx=i, bIdx=i+1;
    const wActive=(viewIndex-1)===wIdx, bActive=(viewIndex-1)===bIdx;
    parts.push(
      `<span class="mv-num">${num}.</span> `+
      (wSan?`<span class="mv ${wActive?'active':''}" data-idx="${wIdx}" title="Stellung nach ${wSan}">${wSan}</span>`:'')+
      (bSan?` <span class="mv ${bActive?'active':''}" data-idx="${bIdx}" title="Stellung nach ${bSan}">${bSan}</span>`:'')
    );
  }

  movesPre.innerHTML = parts.join('');
}

// Interaktion
let selected=null;
async function onSquareClick(x,y){
  if(viewIndex!==masterHistory.length) return;
  const g=buildGameFromHistory(masterHistory.length);
  const piece=g.at(x,y);
  if(!selected){
    if(piece==='.') return;
    const color=(piece===piece.toUpperCase())?'w':'b';
    if(color!==g.turn) return;
    selected=[x,y];
    highlight(x,y,g);
  } else {
    const legal=g.legalMoves();
    let found=null;
    for(const lm of legal) if(lm.from[0]===selected[0] && lm.from[1]===selected[1] && lm.to[0]===x && lm.to[1]===y){ found=lm; break; }
    if(found){
      // Promotion intercept: ensure choice before applying the move
      const movingPiece = g.at(selected[0], selected[1]);
      if(isPromotionMove(g, found, selected[0], selected[1]) && (!found.meta || !found.meta.promote)){
        const choice = await choosePromotion();
        if(!choice){
          // User cancelled → do not make the move
          selected=null;
          renderBoardFromView();
          return;
        }
        found.meta = Object.assign({}, found.meta||{}, { promote: choice });
      }
      if(viewIndex<masterHistory.length) masterHistory.splice(viewIndex);
      masterHistory.push({from:found.from,to:found.to,meta:found.meta});
      viewIndex=masterHistory.length;
      selected=null;
      renderBoardFromView();
    } else {
      selected=null;
      renderBoardFromView();
    }
  }
}

function highlight(sx,sy,g){
  // Reset board view first (keeps pieces in sync)
  renderBoardFromView();

  const squares = document.querySelectorAll('.square');
  // Remove previous marks
  squares.forEach(el => { el.classList.remove('source','target'); el.style.outline=''; });

  // Mark source
  const srcSel = [...squares].find(el => parseInt(el.dataset.x,10)===sx && parseInt(el.dataset.y,10)===sy);
  if (srcSel) srcSel.classList.add('source');

  // Mark legal target squares using real move generation
  try {
    const legal = g.legalMoves();
    for(const lm of legal){
      if(lm.from && lm.from[0]===sx && lm.from[1]===sy){
        const tx = lm.to[0], ty = lm.to[1];
        const tgt = [...squares].find(el => parseInt(el.dataset.x,10)===tx && parseInt(el.dataset.y,10)===ty);
        if (tgt) tgt.classList.add('target');
      }
    }
  } catch(e){
    // Fallback: no targets marked if legalMoves not available
    console.warn('Highlight: legalMoves() failed', e);
  }
}

// Promotion helper: UI overlay returns a Promise<'q'|'r'|'b'|'n'|null>
function choosePromotion(){
  return new Promise((resolve)=>{
    const backdrop = document.getElementById('promotionBackdrop');
    const cancelBtn = document.getElementById('promoCancel');
    const btns = Array.from(document.querySelectorAll('.promo-btn'));
    function cleanup(){
      btns.forEach(b=>b.removeEventListener('click', onPick));
      cancelBtn && cancelBtn.removeEventListener('click', onCancel);
      backdrop.style.display='none';
      backdrop.setAttribute('aria-hidden','true');
    }
    function onPick(e){
      const v = e.currentTarget.getAttribute('data-piece');
      cleanup();
      resolve(v || null);
    }
    function onCancel(){
      cleanup();
      resolve(null); // user aborted; no move applied
    }
    btns.forEach(b=>b.addEventListener('click', onPick));
    cancelBtn && cancelBtn.addEventListener('click', onCancel);
    backdrop.style.display='flex';
    backdrop.setAttribute('aria-hidden','false');
  });
}

// Detect if a move is a pawn promotion (to last rank)
function isPromotionMove(game, move, fromX, fromY){
  try{
    const piece = game.at(fromX, fromY);
    if(!piece || piece.toLowerCase()!=='p') return false;
    const isWhite = piece === piece.toUpperCase();
    const lastRank = isWhite ? 0 : 7;
    return move.to[1] === lastRank;
  }catch(e){ return false; }
}

// Header-Reset Helper
function resetHeadersToQuestionMarks(){
  set('hdrEvent','?'); set('hdrSite','?'); set('hdrDate','?'); set('hdrRound','?');
  set('hdrWhite','?'); set('hdrBlack','?'); set('hdrResult','*'); set('hdrECO','?');
  set('hdrWhiteElo','?'); set('hdrBlackElo','?'); set('hdrPlyCount','0');
}

// Controls
document.getElementById('btnStart').addEventListener('click',()=>{ viewIndex = 0; selected = null; renderBoardFromView(); });
document.getElementById('btnEnd').addEventListener('click',()=>{ viewIndex = masterHistory.length; selected = null; renderBoardFromView(); });
document.getElementById('btnBack').addEventListener('click',()=>{ if(viewIndex>0) viewIndex--; renderBoardFromView(); selected=null; });
document.getElementById('btnForward').addEventListener('click',()=>{ if(viewIndex<masterHistory.length) viewIndex++; renderBoardFromView(); selected=null; });
document.getElementById('btnUndo').addEventListener('click',()=>{ if(viewIndex<masterHistory.length) masterHistory.splice(viewIndex); else if(masterHistory.length>0) masterHistory.pop(); viewIndex=masterHistory.length; selected=null; renderBoardFromView(); });
document.getElementById('btnFlip').addEventListener('click',()=>{ orientationWhite=!orientationWhite; renderBoardFromView(); });
document.getElementById('btnSave').addEventListener('click',()=>{ // Single-Game-Export
  persistCurrentGame(); const g=allePartien[aktuellePartie]; const pgn=buildPGNForGame(g);
  const suggested=(g.headers.White||'?')+"_vs_"+(g.headers.Black||'?')+".pgn";
  const blob=new Blob([pgn],{type:'text/plain'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=suggested; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1000);
});

// Datei/Listen-Aktionen
document.getElementById('btnAddGame').addEventListener('click',()=>{
  persistCurrentGame();
  const confirmed = window.confirm("Achtung: Nicht gespeicherte Änderungen der aktuellen Partie gehen verloren.\n\nNeue Partie wirklich hinzufügen?");
  if (!confirmed) return;
  allePartien.push(newEmptyGame());
  aktuellePartie = allePartien.length - 1;
  loadGame(aktuellePartie);
});
document.getElementById('btnShowList').addEventListener('click', openList);
document.getElementById('btnCloseList').addEventListener('click', closeList);
document.getElementById('modalBackdrop').addEventListener('click',(e)=>{ if(e.target.id==='modalBackdrop') closeList(); });
document.getElementById('btnExportAll').addEventListener('click', exportAllPGN);
document.getElementById('btnOpenPGN').addEventListener('click', openPGNDialogAndImport);

// Öffnen (PGN)
async function openPGNDialogAndImport(){
  const proceed = window.confirm("Beim Öffnen wird der aktuelle Stand überschrieben.\n\nMöchten Sie wirklich fortfahren?");
  if (!proceed) return;
  try{
    if (window.showOpenFilePicker){
      const [handle] = await window.showOpenFilePicker({ multiple:false, types:[{ description:'PGN-Dateien', accept:{ 'text/plain':['.pgn'] } }] });
      const file = await handle.getFile();
      const text = await file.text();
      importPGNText(text);
      return;
    }
  }catch(e){ console.warn('showOpenFilePicker abgebrochen/fehlgeschlagen, Fallback:', e); }
  const inp = document.getElementById('fileInputPGN');
  inp.onchange = async () => {
    const f = inp.files && inp.files[0];
    if(!f) return;
    const text = await f.text();
    importPGNText(text);
    inp.value = '';
  };
  inp.click();
}

// Einfacher PGN-Importer (Headers + grobe SAN-zu-History)
function importPGNText(text){
  removeEmptyStartGame();
  const chunks = text.split(/\n(?=\[Event\s)/g);
  let imported = 0;
  chunks.forEach(chunk => {
    const trimmed = chunk.trim();
    if(!trimmed) return;
    const headers = parsePGNHeaders(trimmed);
    const estimatedPly = estimatePlyCount(trimmed);
    const g = newEmptyGame();
    g.headers = Object.assign(defaultHeaders(), headers);
    g.headers.PlyCount = String(estimatedPly);
    try { const hist = parseHistoryFromPGN(trimmed); if(hist && hist.length){ g.history = hist; g.headers.PlyCount = String(hist.length); } } catch(e){ console.warn('PGN Parsing error:', e); }
    allePartien.push(g);
    imported++;
  });
  if(imported>0){
    aktuellePartie = allePartien.length-1;
    loadGame(aktuellePartie);
    openList();
  } else {
    alert('Keine Partien in der Datei erkannt.');
  }

    try { if (typeof showToast === 'function') { setTimeout(() => { if (typeof showToast === 'function') showToast('PGN erfolgreich importiert ✅'); }, 300); } } catch(e) {}
}
  if (typeof window !== 'undefined') { window.importPGNText = importPGNText; }

function parsePGNHeaders(txt){
  const h = {};
  const regex = /^\[([A-Za-z0-9]+)\s+"(.*)"\]/gm;
  let m;
  while((m = regex.exec(txt))){ h[m[1]] = m[2]; }
  return h;
}
function estimatePlyCount(txt){
  const pairs = (txt.match(/\d+\./g) || []).length;
  return Math.max(0, pairs*2);
}

// Tastatur
document.addEventListener('keydown',(e)=>{
  const active=document.activeElement;
  if(active && (active.tagName==='INPUT'||active.tagName==='TEXTAREA'||active.isContentEditable)) return;
  if(e.key==='ArrowLeft') document.getElementById('btnBack').click();
  if(e.key==='ArrowRight') document.getElementById('btnForward').click();
});

// SAN-Parsing minimal (für Import)
function algToCoord(sq){
  const file = sq[0].toLowerCase().charCodeAt(0) - 97;
  const rank = parseInt(sq[1],10);
  const y = 8 - rank;
  const x = file;
  return [x,y];
}
function stripPGNToSANText(txt){
  let t = txt.replace(/^\s*\[[^\]]*\]\s*$/mg, '');
  t = t.replace(/\{[^}]*\}/g, ' ');
  t = t.replace(/\([^)]*\)/g, ' ');
  t = t.replace(/\$\d+/g, ' ');
  t = t.replace(/\s+/g, ' ').trim();
  return t;
}
function isResultToken(tok){ return tok==='1-0' || tok==='0-1' || tok==='1/2-1/2' || tok==='*'; }
function parseHistoryFromPGN(txt){
  const sanText = stripPGNToSANText(txt);
  const tokens = sanText.split(/\s+/);
  const g = new Game(); g.reset();
  const hist = [];
  for(let t of tokens){
    if(/^\d+\.+$/.test(t)) continue;
    if(/^\d+\.\.\.$/.test(t)) continue;
    if(isResultToken(t)) break;
    const mv = matchSAN(t, g);
    if(mv){ g.makeMove(mv); hist.push(mv); }
  }
  return hist;
}
function matchSAN(san, g){
  san = san.replace(/[+#]+/g,'');
  if(san==='O-O' || san==='0-0'){
    const side = g.turn;
    return g.legalMoves().find(m => m.meta && (m.meta.castle=== (side==='w'?'K':'k')) ) || null;
  }
  if(san==='O-O-O' || san==='0-0-0'){
    const side = g.turn;
    return g.legalMoves().find(m => m.meta && (m.meta.castle=== (side==='w'?'Q':'q')) ) || null;
  }
  let promo = null;
  const promoMatch = san.match(/=([QRBN])/i);
  if(promoMatch){ promo = promoMatch[1].toUpperCase(); san = san.replace(/=([QRBN])/i,''); }
  let pieceLetter = null;
  if(/^[KQRBN]/.test(san)){ pieceLetter = san[0]; san = san.slice(1); }
  const isCapture = san.includes('x');
  san = san.replace('x','');
  const targetSq = san.slice(-2);
  const [tx,ty] = algToCoord(targetSq);
  let disambig = san.slice(0, san.length-2);
  let wantFile = null, wantRank = null;
  if(disambig){
    const m = disambig.match(/^([a-h])?([1-8])?$/i);
    if(m){
      wantFile = m[1] ? (m[1].toLowerCase().charCodeAt(0)-97) : null;
      wantRank = m[2] ? (8-parseInt(m[2],10)) : null;
    } else if(/^[a-h]$/.test(disambig)){
      wantFile = disambig.toLowerCase().charCodeAt(0)-97;
    }
  }
  const moves = g.legalMoves();
  let cands = moves.filter(m => m.to[0]===tx && m.to[1]===ty);
  if(pieceLetter){
    const targetPiece = pieceLetter;
    cands = cands.filter(m => g.at(m.from[0], m.from[1]).toUpperCase()===targetPiece);
  } else {
    cands = cands.filter(m => g.at(m.from[0],m.from[1]).toUpperCase()==='P');
  }
  if(isCapture){
    cands = cands.filter(m => {
      const t = g.at(m.to[0], m.to[1]);
      return (t!=='.') || (m.meta && m.meta.enpassant);
    });
  }
  if(wantFile!==null){ cands = cands.filter(m => m.from[0]===wantFile); }
  if(wantRank!==null){ cands = cands.filter(m => m.from[1]===wantRank); }
  if(promo){ cands = cands.filter(m => m.meta && m.meta.promote && m.meta.promote.toUpperCase()===promo); }
  return cands[0] || null;
}

// Klick auf Zugliste → Stellung anzeigen
(function(){
  const list = document.getElementById('movesPre');
  if(!list) return;
  list.addEventListener('click', (e)=>{
    const el = e.target.closest('.mv');
    if(!el) return;
    const idx = Number(el.dataset.idx);
    if(!Number.isFinite(idx)) return;
    selected = null;
    viewIndex = idx + 1;
    renderBoardFromView();
  });
})();

// Startzustand
allePartien.push(newEmptyGame());
loadGame(0);

}); // DOMContentLoaded
</script>
<!-- Promotion Overlay -->
<div aria-hidden="true" class="modal-backdrop" id="promotionBackdrop" style="display:none">
<div aria-labelledby="promotionTitle" aria-modal="true" class="modal" role="dialog">
<h3 id="promotionTitle">♟️ Bauernumwandlung</h3>
<p>Bitte wähle die gewünschte Figur:</p>
<div class="promo-grid">
<button class="promo-btn" data-piece="q" title="Dame"><span class="pi">♕</span><span>Dame</span></button>
<button class="promo-btn" data-piece="r" title="Turm"><span class="pi">♖</span><span>Turm</span></button>
<button class="promo-btn" data-piece="b" title="Läufer"><span class="pi">♗</span><span>Läufer</span></button>
<button class="promo-btn" data-piece="n" title="Springer"><span class="pi">♘</span><span>Springer</span></button>
</div>
<div class="actions" style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
<button id="promoCancel">Abbrechen</button>
</div>
</div>
</div>
<div aria-modal="true" id="pgnImportBackdrop" role="dialog">
<div class="modal-like" id="pgnImportModal">
<div class="pgn-import-title">PGN-Text importieren</div>
<div class="content">
<label for="pgnImportText">Füge hier deinen PGN-Text ein (eine oder mehrere Partien):</label>
<textarea id="pgnImportText" placeholder='[Event "Beispiel"]
[Site "Hamm"]
[Date "2025.10.24"]
[Round "1"]
[White "Weiß"]
[Black "Schwarz"]
[Result "1-0"]

1. e4 e5 2. Nf3 Nc6 3. Bb5 a6 1-0'></textarea>
</div>
<div class="actions">
<button class="ghost" id="pgnImportCancel">Abbrechen</button>
<button class="primary" id="pgnImportDo">Importieren</button>
</div>
</div>
</div>
<script>
(function(){
  const btnOpen = document.getElementById('btnImportPGNText');
  const backdrop = document.getElementById('pgnImportBackdrop');
  const ta = document.getElementById('pgnImportText');
  const btnCancel = document.getElementById('pgnImportCancel');
  const btnDo = document.getElementById('pgnImportDo');

  function openModal(){
    if(!backdrop) return;
    backdrop.style.display = 'flex';
    setTimeout(()=>{ ta && ta.focus(); }, 0);
  }
  function closeModal(){
    if(!backdrop) return;
    backdrop.style.display = 'none';
  }

  if(btnOpen){ btnOpen.addEventListener('click', openModal); }
  if(btnCancel){ btnCancel.addEventListener('click', closeModal); }

  if(btnDo){
    btnDo.addEventListener('click', ()=>{
      const txt = (ta && ta.value) ? ta.value.trim() : '';
      if(!txt){
        alert('Bitte PGN-Text einfügen.');
        return;
      }
      try{
        if(typeof importPGNText === 'function'){
          importPGNText(txt);
        }else if(typeof window.importPGNText === 'function'){
          window.importPGNText(txt);
        }else{
          console.warn('importPGNText() nicht gefunden.');
          alert('Importfunktion nicht gefunden. Bitte die Datei-Version prüfen.');
          return;
        }
        closeModal();
      }catch(err){
        console.error('Fehler beim Import:', err);
        alert('Fehler beim Import: ' + err.message);
      }
    });
  }

  document.addEventListener('keydown', (e)=>{
    if(e.key === 'Escape' && backdrop && backdrop.style.display === 'flex'){
      closeModal();
    }
  });
  if(backdrop){
    backdrop.addEventListener('click', (e)=>{
      if(e.target === backdrop) closeModal();
    });
  }
})();
</script>
<script>
(function(){
  document.addEventListener('DOMContentLoaded', function(){
    var modal = document.getElementById('importPgnModal');
    if(!modal) return;
    // MutationObserver, um zu erkennen, wann das Fenster geschlossen wird
    var obs = new MutationObserver(function(mutations){
      mutations.forEach(function(m){
        if(m.attributeName === 'style' || m.attributeName === 'class'){
          var hidden = window.getComputedStyle(modal).display === 'none' || modal.classList.contains('hidden');
          if(hidden){
            // Toast nach Schließen des Fensters anzeigen
            setTimeout(function(){
              if(typeof showToast === 'function') showToast('PGN erfolgreich importiert ✅');
            }, 100);
          }
        }
      });
    });
    obs.observe(modal, { attributes: true });
  });
})();
</script>
<script id="cleanup-empty-game">
function removeEmptyStartGame(){
  try{
    if(Array.isArray(allePartien) && allePartien.length===1){
      var g = allePartien[0];
      var isEmpty = g && (!g.moves || g.moves.length===0);
      if(isEmpty){
        allePartien = [];
        if(typeof renderGameList==='function') renderGameList();
        if(typeof updateGameCounters==='function') updateGameCounters();
        console.log('🧹 Leere Startpartie automatisch entfernt.');
      }
    }
  }catch(e){ console.warn('Cleanup skipped', e); }
}

// Beim Laden sofort und kurz versetzt ausführen (falls die Erst-Render erst nachher kommt)
document.addEventListener('DOMContentLoaded', function(){
  try { removeEmptyStartGame(); } catch(e){}
  setTimeout(function(){ try { removeEmptyStartGame(); } catch(e){} }, 150);
  setTimeout(function(){ try { removeEmptyStartGame(); } catch(e){} }, 400);
});
</script>
<script id="moves-classic-js">
// === V5-r20: Klassische Zugliste Rekonstruktion ===
// Wir beobachten #movesPre und formen die flache Folge (mv-num, mv, mv, mv-num, ...)
// in eine dreispaltige Tabelle um: [Nummer] [Weiß] [Schwarz].
// Dabei bleiben eventuelle Click-Handler auf den .mv-Elementen erhalten (Nodes werden nur umgehängt).

(function() {
  const containerId = "movesPre";

  function flattenIfNeeded(root) {
    // Falls bereits eine Tabelle existiert, aber die Quelle neu gezeichnet wurde,
    // räumen wir auf und stellen die flache Struktur wieder her, bevor wir neu gruppieren.
    const table = root.querySelector(':scope > .mv-table');
    if (!table) return;
    const fragment = document.createDocumentFragment();
    // NUR ursprüngliche .mv-num und .mv Kinder sammeln:
    table.querySelectorAll('.mv-num, .mv').forEach(node => {
      fragment.appendChild(node);
    });
    root.innerHTML = "";
    root.appendChild(fragment);
  }

  function buildClassic() {
    const root = document.getElementById(containerId);
    if (!root) return;

    // Wenn die Engine/Renderer bereits einmal gruppiert hat, erst flatten:
    const alreadyClassic = !!root.querySelector(':scope > .mv-table');
    if (alreadyClassic) flattenIfNeeded(root);

    // Sammle flache Kinder in Sequenz
    const items = Array.from(root.children).filter(el => el.classList.contains('mv') || el.classList.contains('mv-num'));
    if (items.length === 0) return;

    // Baue Tabelle
    const table = document.createElement('div');
    table.className = 'mv-table';

    let i = 0;
    while (i < items.length) {
      // Suche nächste Nummer
      while (i < items.length && !items[i].classList.contains('mv-num')) i++;
      if (i >= items.length) break;

      const num = items[i++]; // .mv-num
      // Weiß
      let w = null, b = null;
      if (i < items.length && items[i].classList.contains('mv')) w = items[i++];
      if (i < items.length && items[i].classList.contains('mv')) b = items[i++];

      const row = document.createElement('div');
      row.className = 'mv-row';

      // Spalte: Nummer (rechtsbündig)
      num.classList.add('mv-cell-num');
      table.appendChild(num);

      // Spalte: Weiß
      const wCell = document.createElement('div');
      wCell.className = 'mv-cell mv-white';
      if (w) wCell.appendChild(w);
      table.appendChild(wCell);

      // Spalte: Schwarz
      const bCell = document.createElement('div');
      bCell.className = 'mv-cell mv-black';
      if (b) bCell.appendChild(b);
      table.appendChild(bCell);
    }

    // Ersetze Inhalt
    root.innerHTML = "";
    root.appendChild(table);
  }

  function scheduleRebuild() {
    // Verhindert zu häufiges Neuzeichnen bei schnellen Mutationen
    if (scheduleRebuild._t) cancelAnimationFrame(scheduleRebuild._t);
    scheduleRebuild._t = requestAnimationFrame(buildClassic);
  }

  function initObserver() {
    const root = document.getElementById(containerId);
    if (!root) return;
    // Initialer Build nach DOMContentLoaded
    buildClassic();

    // Beobachte Änderungen an der Zugliste (Engine/Logik rendert dort hinein)
    const mo = new MutationObserver(scheduleRebuild);
    mo.observe(root, { childList: true, subtree: true });

    // Optional: bei Fenstergröße neu berechnen (falls Schrift/Zoom sich ändert)
    window.addEventListener('resize', scheduleRebuild);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initObserver);
  } else {
    initObserver();
  }
})();

// === Scroll-Fix für klassische Zugliste (V5-r22) ===
function scrollToActiveMove(){
  const root = document.getElementById("movesPre");
  if(!root) return;
  const active = root.querySelector(".mv.active");
  if(!active) return;
  const rect = active.getBoundingClientRect();
  const parentRect = root.getBoundingClientRect();
  const fullyVisible = rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;
  if(!fullyVisible){
    active.scrollIntoView({block:"nearest", behavior:"smooth"});
  }
}

(function(){
  const originalBuildClassic = buildClassic;
  buildClassic = function(){
    const root = document.getElementById("movesPre");
    if(!root) return;
    const prevScroll = root.scrollTop;
    originalBuildClassic();
    // Nach Neuzeichnen: aktivem Zug folgen
    requestAnimationFrame(()=>scrollToActiveMove());
  };
})();

// === Scroll-Fix 2.0 für klassische Zugliste (V5-r23) ===
function scrollToActiveMove(){
  const root = document.getElementById("movesPre");
  if(!root) return;
  const active = root.querySelector(".mv.active");
  if(active){
    const rect = active.getBoundingClientRect();
    const parentRect = root.getBoundingClientRect();
    const fullyVisible = rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;
    if(!fullyVisible){
      active.scrollIntoView({block:"nearest", behavior:"smooth"});
    }
  } else {
    // Fallback: falls kein aktiver Zug, nach ganz unten scrollen
    root.scrollTo({top: root.scrollHeight, behavior: "smooth"});
  }
}

(function(){
  const originalBuildClassic = buildClassic;
  buildClassic = function(){
    const root = document.getElementById("movesPre");
    if(!root) return;
    const prevScroll = root.scrollTop;
    originalBuildClassic();
    // Verzögertes Scrollen, damit DOM-Höhe fertig berechnet ist
    setTimeout(()=>{
      scrollToActiveMove();
      // Fallback: falls Scrollhöhe zugenommen hat, aber kein aktiver Zug -> ans Ende
      if(root.scrollTop + root.clientHeight + 20 < root.scrollHeight){
        root.scrollTo({top: root.scrollHeight, behavior:"smooth"});
      }
    }, 120);
  };
})();

// === Scroll-Fix 3.0 für klassische Zugliste (V5-r24) ===
// Reagiert auf Änderungen der aktiven Zugmarkierung (.mv.active)

function ensureActiveVisible(){
  const root = document.getElementById("movesPre");
  if(!root) return;
  const active = root.querySelector(".mv.active");
  if(!active) return;
  const rect = active.getBoundingClientRect();
  const parentRect = root.getBoundingClientRect();
  const fullyVisible = rect.top >= parentRect.top && rect.bottom <= parentRect.bottom;
  if(!fullyVisible){
    active.scrollIntoView({block:"nearest", behavior:"smooth"});
  }
}

(function(){
  const originalBuildClassic = buildClassic;
  buildClassic = function(){
    originalBuildClassic();
    // Nach DOM-Neuaufbau: kurz warten und prüfen
    setTimeout(ensureActiveVisible, 150);
  };

  // Neuer Observer: reagiert auf Änderungen der aktiven Klasse
  const root = document.getElementById("movesPre");
  if(root){
    const obs = new MutationObserver((mutations)=>{
      for(const m of mutations){
        if(m.type === "attributes" && m.attributeName === "class" && m.target.classList.contains("mv") ){
          if(m.target.classList.contains("active")){
            ensureActiveVisible();
            break;
          }
        }
      }
    });
    obs.observe(root, { attributes:true, subtree:true, attributeFilter:["class"] });
  }
})();

// === Scroll-Fix 4.0 „Lichess-Scroll“ (V5-r25) ===
// Scrollt automatisch ans Ende, wenn der Nutzer am unteren Rand war.
// Wenn der Nutzer hochgescrollt hat, bleibt die Position stabil.

(function(){
  const root = document.getElementById("movesPre");
  if(!root) return;
  let userScrolledUp = false;

  // Erkennen, ob der Nutzer manuell hochscrollt
  root.addEventListener("scroll", () => {
    const atBottom = root.scrollTop + root.clientHeight >= root.scrollHeight - 40;
    userScrolledUp = !atBottom;
  });

  function scrollToEndIfNeeded(){
    if(!userScrolledUp){
      root.scrollTo({top: root.scrollHeight, behavior:"smooth"});
    }
  }

  // Wrap buildClassic, um nach jedem Rebuild zu prüfen
  const originalBuildClassic = buildClassic;
  buildClassic = function(){
    originalBuildClassic();
    // Kurze Verzögerung, bis DOM stabil ist
    setTimeout(scrollToEndIfNeeded, 120);
  };

  // Beobachte Änderungen an aktiven Zügen – optionales Feintuning
  const mo = new MutationObserver(scrollToEndIfNeeded);
  mo.observe(root, { childList:true, subtree:true });

})();
</script>
<script id="scroll-fix-50-shim">
(function(){
  document.addEventListener('click', function(e){
    const t = e.target.closest('.mv');
    if(!t) return;
    if(window.__HS_scrollFix){
      // Manuelle Navigation -> sticky temporär deaktivieren (nearest)
      if (window.__HS_scrollFix.setStickyEnabled) window.__HS_scrollFix.setStickyEnabled(false);
      const idx = parseInt(t.dataset.mvIndex || '-1', 10);
      if(!Number.isNaN(idx)) window.__HS_scrollFix.setActiveMove(idx, { });
    }else{
      document.querySelectorAll('#movesPre .mv.active').forEach(n=>n.classList.remove('active'));
      t.classList.add('active');
      t.scrollIntoView({block:'nearest'});
    }
  });
})();
</script>

<script id="iframe-perfect-fit" defer>
(function(){
  function fitLayout(){
    try{
      var mgmt = document.querySelector('.mgmt');
      var controls = document.querySelector('.controls');
      var status = document.getElementById('status');
      var footer = document.querySelector('footer');
      var vpad = 20; // small extra breathing space

      var mgmtH = mgmt ? mgmt.offsetHeight : 0;
      var controlsH = controls ? controls.offsetHeight : 0;
      var statusH = status ? status.offsetHeight : 0;
      var footerH = footer ? footer.offsetHeight : 0;

      var avail = window.innerHeight - (mgmtH + controlsH + statusH + footerH + vpad);
      // Keep between 320 and 600 to preserve look & feel
      var size = Math.max(320, Math.min(600, avail));

      // If the host iframe is extremely small, still avoid negative sizes
      if(!isFinite(size) || size < 320) size = 320;

      document.documentElement.style.setProperty('--board-size', size + 'px');

      var sidebar = document.querySelector('.sidebar');
      if(sidebar){ sidebar.style.height = size + 'px'; }
    }catch(e){
      // Non-blocking
      console && console.warn && console.warn('fitLayout failed', e);
    }
  }
  window.addEventListener('resize', fitLayout);
  document.addEventListener('DOMContentLoaded', fitLayout);
  // in case the module script renders later, run again after a tick
  setTimeout(fitLayout, 120);
})();
</script>

</body></html>
<script>try{ if(typeof importPGNText==='function'){ window.importPGNText = importPGNText; } }catch(e){ console.warn(e); }</script>
<script id="scroll-fix-50">
/* === Scroll-Fix 5.4 — „Der Befreier“ (2025‑10‑25) ===
   Behoben:
   - Scroll-Blockade bei Zeile 7–8
   - „Zum Anfang der Partie“ friert nicht mehr ein
   - MutationObserver pausiert während Reset
   - Scrollcontainer sicher entsperrt (Safari/Firefox kompatibel)
*/
(function(){
  const ROOT_SELECTOR = '#movesPre';
  const MV_SELECTOR = ROOT_SELECTOR + ' .mv';

  function getRoot(){ return document.querySelector(ROOT_SELECTOR); }

  function getScrollContainer(startEl){
    let el = startEl;
    while (el) {
      const style = el === document.documentElement ? null : getComputedStyle(el);
      const canScroll = el.scrollHeight > el.clientHeight;
      const overflowY = style ? style.overflowY : 'visible';
      if (canScroll && (overflowY === 'auto' || overflowY === 'scroll')) return el;
      el = el.parentElement;
    }
    return document.scrollingElement || document.documentElement;
  }

  function getAllMoves(){ return Array.from(document.querySelectorAll(MV_SELECTOR)); }
  function getActive(){ return document.querySelector(MV_SELECTOR + '.active'); }

  let lastActiveIndex = -1;
  let userOverride = false;
  let observerPaused = false;

  const REARM_THRESHOLD = 60;
  const MARGIN = 36;

  function indexMoves(){
    const moves = getAllMoves();
    moves.forEach((el, i) => el.dataset.mvIndex = String(i));
  }

  function getActiveIndex(){
    const a = getActive();
    if (!a) return -1;
    const v = parseInt(a.dataset.mvIndex || '-1', 10);
    return Number.isNaN(v) ? -1 : v;
  }

  function isNearBottom(container, threshold=REARM_THRESHOLD){
    const max = container.scrollHeight - container.clientHeight;
    return (max - container.scrollTop) <= threshold;
  }

  function smartScrollToActive(mode){
    const root = getRoot();
    if (!root) return;
    const list = getScrollContainer(root);
    const active = getActive();
    if (!active) return;

    const rectA = active.getBoundingClientRect();
    const rectL = list.getBoundingClientRect();
    const aTop = rectA.top - rectL.top + list.scrollTop;
    const aBottom = aTop + rectA.height;
    const viewTop = list.scrollTop;
    const viewBottom = viewTop + list.clientHeight;

    if (mode === 'end') {
      list.scrollTop = Math.max(0, aBottom - list.clientHeight + MARGIN);
      const maxScroll = Math.max(0, list.scrollHeight - list.clientHeight);
      if (maxScroll - list.scrollTop <= MARGIN) list.scrollTop = maxScroll;
      return;
    }
    if (aTop - MARGIN < viewTop) {
      list.scrollTop = Math.max(0, aTop - MARGIN);
    } else if (aBottom + MARGIN > viewBottom) {
      list.scrollTop = Math.min(list.scrollHeight - list.clientHeight, aBottom + MARGIN - list.clientHeight);
    }
  }

  function unlockScroll(list){
    if (!list) return;
    const oldBehavior = list.style.scrollBehavior;
    list.style.scrollBehavior = 'auto';
    list.style.overflowY = 'auto';
    setTimeout(()=>{
      list.style.scrollBehavior = oldBehavior || '';
      list.style.overflowY = '';
    }, 150);
  }

  function performReset(){
    const root = getRoot();
    const list = getScrollContainer(root);
    const moves = getAllMoves();
    userOverride = true;
    observerPaused = true;

    // Entferne alle .active
    document.querySelectorAll(MV_SELECTOR + '.active').forEach(x=>x.classList.remove('active'));
    lastActiveIndex = 0;

    // Scroll nach oben
    list.scrollTop = 0;
    unlockScroll(list);

    // Nach kurzer Pause Observer wieder aktivieren
    setTimeout(()=>{ observerPaused = false; }, 150);

    // Optional ersten Zug markieren, wenn vorhanden
    if (moves.length > 0) {
      moves[0].classList.add('active');
    }
  }

  function setActiveMove(index, opts){
    indexMoves();
    const moves = getAllMoves();
    const cur = getActive();
    if (cur) cur.classList.remove('active');

    let idx = index;
    if (typeof idx !== 'number') {
      if (typeof idx === 'string') idx = parseInt(idx, 10);
      else if (idx && idx.dataset && idx.dataset.mvIndex) idx = parseInt(idx.dataset.mvIndex, 10);
    }
    if (Number.isNaN(idx) || idx < 0) return;

    const el = moves[idx];
    if (!el) return;

    document.querySelectorAll(MV_SELECTOR + '.active').forEach(x=>x.classList.remove('active'));
    el.classList.add('active');
    lastActiveIndex = idx;

    const root = getRoot();
    const list = getScrollContainer(root);

    // Reset-Schutz
    if (idx === 0) {
      performReset();
      return;
    }

    const atEnd = idx >= moves.length - 1;
    const nearBottom = isNearBottom(list);
    const mode = (atEnd && !userOverride && nearBottom) ? 'end' : 'nearest';
    smartScrollToActive(mode);
  }

  function attachUserInteraction(){
    const root = getRoot();
    if (!root) return;
    const list = getScrollContainer(root);
    function onUserIntent(){ userOverride = true; }
    function onScroll(){ if (isNearBottom(list)) userOverride = false; }
    ['wheel','touchstart','pointerdown','mousedown','keydown'].forEach(evt =>
      list.addEventListener(evt, onUserIntent, { passive: true })
    );
    list.addEventListener('scroll', onScroll, { passive: true });
  }

  window.__HS_scrollFix = {
    indexMoves,
    setActiveMove,
    smartScrollToActive,
    setStickyEnabled: (enabled)=>{ userOverride = !enabled; },
    resetScroll: performReset
  };

  document.addEventListener('DOMContentLoaded', () => {
    indexMoves();
    attachUserInteraction();
    const root = getRoot();
    if (!root) return;
    const list = getScrollContainer(root);
    const ai = getActiveIndex();
    if (ai >= 0) {
      lastActiveIndex = ai;
      const initialMode = isNearBottom(list) ? 'end' : 'nearest';
      smartScrollToActive(initialMode);
    }
  });

  const root = getRoot();
  if (root){
    const list = getScrollContainer(root);
    const obs = new MutationObserver(() => {
      if (observerPaused) return; // skip during reset
      const wasNearBottom = isNearBottom(list);
      const savedScroll = list.scrollTop;
      requestAnimationFrame(() => {
        indexMoves();
        const ai = getActiveIndex();
        if (ai >= 0) {
          lastActiveIndex = ai;
          const atEnd = ai >= getAllMoves().length - 1;
          const allowEndStick = atEnd && !userOverride && wasNearBottom;
          smartScrollToActive(allowEndStick ? 'end' : 'nearest');
        } else {
          list.scrollTop = savedScroll;
        }
      });
    });
    obs.observe(root, { childList: true, subtree: true });
  }
})();
</script>
